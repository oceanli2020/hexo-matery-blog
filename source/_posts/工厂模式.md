---
title: 工厂模式
top: false
cover: false
toc: true
mathjax: true
date: 2021-03-14 14:38:01
password:
summary:
tags:
  - 设计模式
  - 工厂模式
categories:
  - 设计模式
---

### 工厂模式

好处：

- 解耦

- 降低代码重复
- 使用者不需要知道具体的创建过程，减少因为创建逻辑导致的错误
- 容易扩展，易于维护

`解耦`：降低各个模块之间的耦合和依赖关系，可以降低维护成本

简单工厂：建立一个工厂类，对实现了同一接口的一些类进行实例的创建

```java
// 抽象产品：手机
public interface Phone {
    void make();
}
// 具体产品：小米手机
public class MiPhone implements Phone {
    public MiPhone(){
        this.make()
    }
    @Override
    public void make(){
        System.out.println("make xiaomi phone!");
    }
}
// 具体产品：苹果手机
public class IPhone implements Phone {
    public IPhone() {
        this.make();
    }
    @Override
    public void make() {
        System.out.println("make iphone!");
    }
}
// 工厂类: 生产不同品牌的手机
public class PhoneFactory {
    public Phone makePhone(String phoneType) {
        if(phoneType.equalsIgnoreCase("MiPhone")){
            return new MiPhone();
        }
        else if(phoneType.equalsIgnoreCase("iPhone")) {
            return new IPhone();
        }
        return null;
    }
}
public class Demo {
    public static void main(String[] arg) {
        PhoneFactory factory = new PhoneFactory();
        Phone miPhone = factory.makePhone("MiPhone");            // make xiaomi phone!
        IPhone iPhone = (IPhone)factory.makePhone("iPhone");    // make iphone!
    }
}
```

方法工厂：创建一个工厂接口和多个工厂实现类，一个工厂实现类负责对一个类进行实例的创建

```java
// 抽象工厂：生产手机的工厂
public interface AbstractFactory {
    Phone makePhone();
}
// 具体工厂：生产小米手机的工厂类
public class XiaoMiFactory implements AbstractFactory{
    @Override
    public Phone makePhone() {
        return new MiPhone();
    }
}
// 具体工厂：生产苹果手机的工厂类
public class AppleFactory implements AbstractFactory {
    @Override
    public Phone makePhone() {
        return new IPhone();
    }
}
public class Demo {
    public static void main(String[] arg) {
        AbstractFactory miFactory = new XiaoMiFactory();
        AbstractFactory appleFactory = new AppleFactory();
        miFactory.makePhone();            // make xiaomi phone!
        appleFactory.makePhone();        // make iphone!
    }
}
```

抽象工厂：

多个抽象产品类，每个抽象产品类可以派生出多个具体产品类

一个抽象工厂类，可以派生出多个具体工厂类

每个具体工厂类可以继承多个工厂接口，实现创建多个具体产品类的实例

```java
// 抽象产品：电脑
public interface PC {
    void make();
}
// 具体产品：小米电脑
public class MiPC implements PC {
    public MiPC() {
        this.make();
    }
    @Override
    public void make() {
        System.out.println("make xiaomi PC!");
    }
}
// 具体产品:苹果电脑
public class MAC implements PC {
    public MAC() {
        this.make();
    }
    @Override
    public void make() {
        System.out.println("make MAC!");
    }
}
// 抽象工厂：生产手机和电脑的工厂
public interface AbstractFactory {
    Phone makePhone();
    PC makePC();  // 增加生产电脑的方法
}

// 具体工厂：生产小米手机和小米电脑的工厂类
public class XiaoMiFactory implements AbstractFactory{
    @Override
    public Phone makePhone() {
        return new MiPhone();
    }
    @Override
    public PC makePC() {
        return new MiPC();
    }
}
// 具体工厂：生产苹果手机和苹果电脑的工厂类
public class AppleFactory implements AbstractFactory {
    @Override
    public Phone makePhone() {
        return new IPhone();
    }
    @Override
    public PC makePC() {
        return new MAC();
    }
}
public class Demo {
    public static void main(String[] arg) {
        AbstractFactory miFactory = new XiaoMiFactory();
        AbstractFactory appleFactory = new AppleFactory();
        miFactory.makePhone();            // make xiaomi phone!
        miFactory.makePC();                // make xiaomi PC!
        appleFactory.makePhone();        // make iphone!
        appleFactory.makePC();            // make MAC!
    }
}
```
