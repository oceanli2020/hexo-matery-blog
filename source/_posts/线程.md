---
title: 线程
top: true
cover: false
toc: true
mathjax: true
date: 2021-03-14 10:58:12
password:
summary:
tags:
  - Java
  - 线程
categories:
  - Java
---

#### 线程的创建

继承`Thread`类，并重写 run 方法
实现`Runnable`接口，并重写 run 方法，和 Thread 相比，可以实现资源共享，即多个线程处理同一个资源
实现`Callable`接口，并重写 call 方法，和 run 方法相比，call 方法有返回值

#### 多线程会遇到什么问题？

线程安全问题：多个线程同时操作一个共享变量时，导致数据不一致

解决方法：

- 尽量减少共享资源

- 加锁使线程同步，使某一时刻只允许一个线程在程序中允许

  synchronized 锁：非公平锁、可重入锁
  Lock 锁：默认为非公平锁（可设置为公平锁）、可重入锁

  对比：

  - 发生异常时，synchronized 会自动释放锁，不易导致死锁，Lock 需要用 unLock()主动释放锁，否则会死锁
  - 使用 Lock 锁可以知道是否成功获得锁

  - Lock 锁的效率更高

  `公平锁`：先到先做，`非公平锁`：同时去竞争，可重入锁：递归时不会死锁

- ThreadLocal：在每个线程中存储一个变量的副本，这样每个线程对该变量的操作，使用的是该线程的局部变量，不会对其他线程有任何影响

- Volatile：

  - 可见性：所以线程都能看到该变量的最新状态，每次读取必须从主内存中得到最新的值，每次写入必须立即同步回主内存
  - 有序性：JVM 编译程序时会对语句重排序，而一个变量被声明为 Volatile,则该变量不会进行重排序
  - Volatile 只能保证原子性的操作时线程安全的
  - 适用场景：运算结果不依赖变量的当前值、确保只有单一的线程修改变量的值

#### 死锁

两个线程互相等待对方释放锁，没有异常，没有提示，都进入阻塞

银行家算法
